// checkpoint for adding to sum:

using System.Collections.Generic;
using UnityEngine;

// Enum for selecting RH fields
public enum RHValue
{
    RH2,
    RH50,
    RH98
}

public class WaveformVisualizer : MonoBehaviour
{
    public CSVParser csvParser;
    public Material waveformMaterial;
    public float scale = 25f;                  // Scale to place cylinders
    public float gridCellSize = 10f;           // Size of each grid cell
    public RHValue selectedRHField = RHValue.RH98; // Selected RH field (default to RH98)
    public float targetSum = 25.0f;         // Target sum for normalization

    private List<GameObject> currentCylinders = new List<GameObject>();

    // Start is called before the first frame update
    void Start()
    {
        if (csvParser != null)
        {
            // Ensure the CSV is loaded
            if (csvParser.getDataPoints() == null || csvParser.getDataPoints().Count == 0)
            {
                csvParser.loadCSV();  // Load CSV if data is null
            }

            List<CSVParser.GEDIDataPoint> dataPoints = csvParser.getDataPoints();
            if (dataPoints != null)
            {
                // Visualize data
                VisualizeData(dataPoints);
            }
            else
            {
                Debug.LogError("Data points are null.");
            }
        }
        else
        {
            Debug.LogError("CSVParser is not assigned.");
        }
    }

    // Retrieve the selected RH value based on the current selection
    private float GetSelectedRHValue(CSVParser.GEDIDataPoint point)
    {
        switch (selectedRHField)
        {
            case RHValue.RH2:
                return point.rh2;
            case RHValue.RH50:
                return point.rh50;
            case RHValue.RH98:
                return point.rh98;
            default:
                return point.rh98;
        }
    }

    // Visualize data by creating generalized cylinders
    public void VisualizeData(List<CSVParser.GEDIDataPoint> dataPoints)
    {
        foreach (var point in dataPoints)
        {
            Vector3 pos = LatLong2Unity(point.latitude, point.longitude, point.elevation);
            float selectedRH = GetSelectedRHValue(point);
            CreateGeneralizedCylinder(pos, point.rawWaveform, selectedRH);
        }
    }

    // Convert latitude, longitude, elevation to Unity coordinates
    private Vector3 LatLong2Unity(float latitude, float longitude, float elevation)
    {
        float x = longitude * scale;
        float y = elevation * (1 / scale);
        float z = latitude * scale;
        return new Vector3(x, y, z);
    }

    // Create a generalized cylinder based on waveform data
    private void CreateGeneralizedCylinder(Vector3 position, string rawWaveform, float height)
    {
        // Parse waveform data as an array of floats
        float[] waveformValues = ParseWaveform(rawWaveform);

        // Create a new GameObject to hold the mesh
        GameObject waveformObject = new GameObject("WaveformCylinder");
        waveformObject.transform.position = position;

        // Add MeshFilter and MeshRenderer components
        MeshFilter meshFilter = waveformObject.AddComponent<MeshFilter>();
        MeshRenderer meshRenderer = waveformObject.AddComponent<MeshRenderer>();
        meshRenderer.material = waveformMaterial;

        // Create a mesh based on the waveform data
        Mesh mesh = GenerateCylinderMesh(waveformValues, height);
        meshFilter.mesh = mesh;

        // Add to the list for tracking
        currentCylinders.Add(waveformObject);
    }

    // Parse waveform with normalization based on the sum of the waveform values
    private float[] ParseWaveform(string waveform)
    {
        string[] values = waveform.Split(',');
        float[] waveformValues = new float[values.Length];
        float sumValue = 0f;

        // Parse the waveform values and calculate the sum
        for (int i = 0; i < values.Length; i++)
        {
            if (float.TryParse(values[i], out float parsedValue))
            {
                waveformValues[i] = parsedValue;
                sumValue += waveformValues[i];
            }
            else
            {
                Debug.LogWarning($"Unable to parse value: {values[i]}");
                waveformValues[i] = 0f;
            }
        }
        // Debug.Log($"Sum of waveform values: {sumValue}");

        if (sumValue > 0)
        {
            float scaleFactor = targetSum / sumValue;
            Debug.Log($"scaleFactor: {scaleFactor}");
            for (int i = 0; i < waveformValues.Length; i++)
            {
                waveformValues[i] *= scaleFactor;

            }
        }
        else
        {
            // If the sum is zero, set all values to an equal fraction of targetSum
            float equalValue = targetSum / waveformValues.Length;
            for (int i = 0; i < waveformValues.Length; i++)
            {
                waveformValues[i] = equalValue;
            }
        }

        return waveformValues;
    }

    // Generate a cylinder mesh based on waveform values and height
    private Mesh GenerateCylinderMesh(float[] waveformValues, float height)
    {
        int segments = waveformValues.Length;          // Number of radial segments from the waveform
        List<Vector3> vertices = new List<Vector3>();
        List<int> triangles = new List<int>();

        int circleResolution = 12;                     // Number of points in each circular cross-section
        float angleIncrement = Mathf.PI * 2 / circleResolution;

        // Generate vertices for each cross-section along the height
        for (int i = 0; i < segments; i++)
        {
            float radius = waveformValues[i]; // Use normalized value as radius

            float y = (i / (float)(segments - 1)) * height;

            // Create vertices in a circular pattern for this height
            for (int j = 0; j < circleResolution; j++)
            {
                float angle = j * angleIncrement;
                float x = radius * Mathf.Cos(angle);
                float z = radius * Mathf.Sin(angle);
                vertices.Add(new Vector3(x, y, z));
            }
        }

        // Generate triangles between consecutive cross-sections
        for (int i = 0; i < segments - 1; i++)
        {
            int startIndex = i * circleResolution;
            int nextIndex = (i + 1) * circleResolution;

            for (int j = 0; j < circleResolution; j++)
            {
                int current = startIndex + j;
                int next = startIndex + (j + 1) % circleResolution;
                int top = nextIndex + j;
                int topNext = nextIndex + (j + 1) % circleResolution;

                // First triangle
                triangles.Add(current);
                triangles.Add(next);
                triangles.Add(top);

                // Second triangle
                triangles.Add(next);
                triangles.Add(topNext);
                triangles.Add(top);
            }
        }

        // Create the mesh
        Mesh mesh = new Mesh();
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();
        mesh.RecalculateNormals(); // Recalculate for proper shading

        return mesh;
    }

    // Clear all cylinders
    public void ClearVisualization()
    {
        foreach (var cyl in currentCylinders)
        {
            Destroy(cyl);
        }
        currentCylinders.Clear();
    }

    // Refresh visualization
    public void RefreshVisualization()
    {
        ClearVisualization();
        if (csvParser != null)
        {
            List<CSVParser.GEDIDataPoint> dataPoints = csvParser.getDataPoints();
            if (dataPoints != null)
            {
                VisualizeData(dataPoints);
            }
            else
            {
                Debug.LogError("RefreshVisualization: Data points are null.");
            }
        }
        else
        {
            Debug.LogError("RefreshVisualization: CSVParser is not assigned.");
        }
    }
}